package designPattern.creational;

public class DoubleCheckLocking {
// Works with acquire/release semantics for volatile in Java 1.5 and later
// Broken under Java 1.4 and earlier semantics for volatile

//Note the local variable "localRef", which seems unnecessary. T
//The effect of this is that in cases where helper is already initialized
// (i.e., most of the time), the volatile field is only accessed once (due to "return localRef;"
// instead of "return helper;"), which can improve the method's overall performance by as much as 25 percent

/*Intuitively, this algorithm seems like an efficient solution to the problem. However, this technique has many subtle
problems and should usually be avoided (before Java 1.5 without volatile). For example,
consider the following sequence of events:

    Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
    Due to the semantics of some programming languages, the code generated by the compiler is allowed to update
    the shared variable to point to a partially constructed object before A has finished performing the initialization.
    For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated
    once the storage has been allocated but before the inlined constructor initializes the object.
    Thread B notices that the shared variable has been initialized (or so it appears), and returns its value.
    Because thread B believes the value is already initialized, it does not acquire the lock.
    If B uses the object before all of the initialization done by A is seen by B
    (either because A has not finished initializing it or because some of the initialized values in the object have not
    yet percolated to the memory B uses (cache coherence)), the program will likely crash.
*/
    private DoubleCheckLocking(){};
    private static volatile  DoubleCheckLocking instance;


    public static DoubleCheckLocking getInstance() {
        DoubleCheckLocking localRefToinstance = instance;
        if (localRefToinstance == null){
            synchronized (DoubleCheckLocking.instance) {
                if (localRefToinstance == null) {
                    instance = localRefToinstance = new DoubleCheckLocking();
                }
            }
        }
        return localRefToinstance;
    }
}
